
import PptxGenJS from "pptxgenjs";
import { PresentationData, SlideType } from "../types";

export const createPPTX = (data: PresentationData) => {
  const pres = new PptxGenJS();
  
  // Set Metadata
  pres.title = data.topic;
  pres.subject = "Generated by Gemini";
  pres.layout = "LAYOUT_16x9";

  // Define a master slide for background
  pres.defineSlideMaster({
    title: "MASTER_SLIDE",
    background: { color: "F8FAFC" },
    objects: [
      {
        rect: { x: 0, y: "95%", w: "100%", h: "5%", fill: { color: data.themeColor || "0078D7" } },
      },
      // Footer: Date and Topic
      {
         text: {
             text: new Date().toLocaleDateString() + " | " + data.topic,
             options: { x: 0.3, y: "96%", w: "50%", h: 0.3, fontSize: 10, color: "FFFFFF", align: "left" }
         }
      },
      // Footer: Slide Number Label
      {
         text: {
             text: "Page",
             options: { x: "85%", y: "96%", w: "5%", h: 0.3, fontSize: 10, color: "FFFFFF", align: "right" }
         }
      }
    ],
    slideNumber: { x: "90%", y: "96%", w: "5%", h: 0.3, fontSize: 10, color: "FFFFFF", align: "center" }
  });

  data.slides.forEach((slide, index) => {
    const pptSlide = pres.addSlide({ masterName: "MASTER_SLIDE" });
    
    // 1. Add Transition to every slide (Dynamic Element)
    (pptSlide as any).transition = { type: "fade", speed: "slow" };

    if (slide.speakerNotes) {
      pptSlide.addNotes(slide.speakerNotes);
    }

    // --- Slide Logic based on Type ---

    switch (slide.type) {
      case SlideType.TITLE:
        pptSlide.background = { color: "FFFFFF" };
        
        // Design Element: Gradient Sidebar
        pptSlide.addShape(pres.ShapeType.rect, { 
            x: 0, y: 0, w: "35%", h: "100%", 
            fill: { color: data.themeColor || "0078D7" } 
        });
        
        // Title
        pptSlide.addText(slide.title, {
          x: "38%",
          y: "35%",
          w: "60%",
          fontSize: 44,
          bold: true,
          color: "000000",
          align: "left"
        });
        // Subtitle
        if (slide.subtitle) {
          pptSlide.addText(slide.subtitle, {
            x: "38%",
            y: "55%",
            w: "55%",
            fontSize: 24,
            color: "64748B",
            align: "left"
          });
        }
        break;

      case SlideType.CLOSING:
        pptSlide.background = { color: data.themeColor || "0078D7" };
        pptSlide.addText(slide.title, {
          x: 0,
          y: "40%",
          w: "100%",
          fontSize: 48,
          bold: true,
          color: "FFFFFF",
          align: "center",
        });
        if (slide.subtitle) {
          pptSlide.addText(slide.subtitle, {
            x: 0,
            y: "55%",
            w: "100%",
            fontSize: 20,
            color: "E2E8F0",
            align: "center",
          });
        }
        // Dynamic Element: Hyperlink
        if (slide.sourceUrl) {
            pptSlide.addText("了解更多 / Learn More", {
                x: 0, y: "70%", w: "100%", h: 0.5,
                fontSize: 14, color: "FFFFFF", align: "center",
                // Explicit cast to avoid strict type checks on complex objects in some versions
                hyperlink: { url: slide.sourceUrl },
                underline: { style: "sng" } 
            } as any);
        }
        break;

      case SlideType.CONTENT_TEXT:
        // Title
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        // Header underlining
        pptSlide.addShape(pres.ShapeType.line, { x: 0.5, y: 1.3, w: "90%", h: 0, line: { color: "E2E8F0", width: 1 } });
        
        // Bullets
        if (slide.bullets && slide.bullets.length > 0) {
          const formattedBullets = slide.bullets.map((b) => ({
            text: b,
            // Cast options to any to prevent TS errors with complex bullet object
            options: { fontSize: 18, breakLine: true, bullet: { code: "2022" }, paraSpaceBefore: 12 } as any,
          }));
          pptSlide.addText(formattedBullets, { x: 0.5, y: 1.5, w: "90%", h: 4.5, color: "363636", align: "left" });
        }
        break;

      case SlideType.CONTENT_TEXT_IMAGE:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        pptSlide.addShape(pres.ShapeType.line, { x: 0.5, y: 1.3, w: "90%", h: 0, line: { color: "E2E8F0", width: 1 } });
        
        // Left Column: Text
        if (slide.bullets) {
          const formattedBullets = slide.bullets.map((b) => ({
            text: b,
            options: { fontSize: 16, breakLine: true, bullet: { code: "2022" }, paraSpaceBefore: 10 } as any,
          }));
          pptSlide.addText(formattedBullets, { x: 0.5, y: 1.5, w: "45%", h: 4.5, color: "363636" });
        }

        // Right Column: Image with Design Element (Shadow)
        if (slide.imageKeyword) {
          const imageUrl = `https://picsum.photos/seed/${slide.imageKeyword}${index}/800/600`;
          pptSlide.addImage({
            path: imageUrl,
            x: "53%",
            y: 1.5,
            w: "42%",
            h: 3.5,
            sizing: { type: "cover", w: "42%", h: 3.5 },
            shadow: { type: 'outer', color: '000000', opacity: 0.3, blur: 10, offset: 5, angle: 45 }
          });
        }
        break;

      case SlideType.CONTENT_VIDEO:
        // Multimedia Element
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        const videoUrl = slide.videoUrl && slide.videoUrl.startsWith('http') 
             ? slide.videoUrl 
             : "https://www.w3schools.com/html/mov_bbb.mp4"; 

        pptSlide.addMedia({
            type: "video",
            path: videoUrl,
            x: 1, y: 1.5, w: 8, h: 4.5,
            cover: `https://picsum.photos/seed/${slide.imageKeyword || 'video'}/800/600`
        });

        pptSlide.addText("(Video playback requires internet connection)", {
            x: 1, y: 6.1, w: 8, fontSize: 10, color: "94A3B8", align: "center"
        });
        break;

      case SlideType.BIG_NUMBER:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        // Shape with Transparency and Outline
        pptSlide.addShape(pres.ShapeType.ellipse, { 
             x: 3.5, y: 2, w: 3, h: 3, 
             fill: { color: data.themeColor, transparency: 90 },
             line: { color: data.themeColor, width: 2 }
        });

        pptSlide.addText(slide.bigNumber || "100%", {
          x: 0,
          y: "35%",
          w: "100%",
          fontSize: 88,
          bold: true,
          color: data.themeColor,
          align: "center"
        });
        
        if (slide.bigNumberLabel) {
           pptSlide.addText(slide.bigNumberLabel, {
            x: 0,
            y: "65%",
            w: "100%",
            fontSize: 24,
            color: "64748B",
            align: "center"
          });
        }
        break;

      case SlideType.TABLE:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        if (slide.tableHeaders && slide.tableRows) {
          const headers = slide.tableHeaders.map(h => ({ text: h, options: { bold: true, fill: { color: data.themeColor }, color: "FFFFFF" } }));
          const rows = slide.tableRows.map(row => row.map(cell => ({ text: cell, options: { fill: { color: "F1F5F9" }, color: "334155" } })));
          
          pptSlide.addTable([headers, ...rows], {
            x: 0.5,
            y: 1.5,
            w: "90%",
            colW: new Array(headers.length).fill(9 / headers.length), 
            border: { pt: 1, color: "E2E8F0" },
            autoPage: true,
            fontSize: 14
          });
        }
        break;

      case SlideType.QUOTE:
        // Design Element: Full background overlay
        pptSlide.addShape(pres.ShapeType.rect, { x: 0, y: 0, w: "100%", h: "100%", fill: { color: data.themeColor, transparency: 85 } });
        
        // Large Quote Mark
        pptSlide.addText("“", { x: 0.5, y: 1.0, w: 2, h: 2, fontSize: 160, color: data.themeColor, align: "center", bold: true });

        pptSlide.addText(slide.quoteText || "", {
          x: 1.5,
          y: 2.2,
          w: 7,
          fontSize: 28,
          color: "333333",
          align: "center",
          fontFace: "Georgia",
          italic: true
        });

        if (slide.quoteAuthor) {
          pptSlide.addText(`— ${slide.quoteAuthor}`, {
            x: 1.5,
            y: 4.5,
            w: 7,
            fontSize: 18,
            color: "666666",
            align: "right",
            bold: true
          });
        }
        break;

      case SlideType.CHART:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        if (slide.chart) {
          const chartData = [
            {
              name: slide.chart.dataLabel,
              labels: slide.chart.labels,
              values: slide.chart.values,
            },
          ];

          let chartType = pres.ChartType.bar;
          if (slide.chart.type === 'PIE') chartType = pres.ChartType.pie;
          if (slide.chart.type === 'LINE') chartType = pres.ChartType.line;

          pptSlide.addChart(chartType, chartData, {
            x: 1,
            y: 1.5,
            w: 8,
            h: 4.5,
            barDir: "col",
            barGrouping: "clustered",
            chartColors: [data.themeColor, "64748B", "94A3B8", "CBD5E1", "E2E8F0"],
            showLegend: true,
            legendPos: "b"
          });
        }
        break;

      case SlideType.TIMELINE:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        if (slide.timeline && slide.timeline.length > 0) {
          const count = slide.timeline.length;
          const startX = 0.5;
          const totalW = 9;
          const step = totalW / count;
          const lineY = 3.0;

          // Design Element: Dashed Line
          pptSlide.addShape(pres.ShapeType.line, {
            x: startX,
            y: lineY,
            w: totalW,
            h: 0,
            line: { color: data.themeColor, width: 3, dashType: "dash" }
          });

          slide.timeline.forEach((event, i) => {
            const xPos = startX + (i * step) + (step / 2) - 0.2; 
            
            // Marker Shape
            pptSlide.addShape(pres.ShapeType.ellipse, {
              x: xPos,
              y: lineY - 0.15,
              w: 0.3,
              h: 0.3,
              fill: { color: "FFFFFF" },
              line: { color: data.themeColor, width: 3 }
            });

            // Year
            pptSlide.addText(event.year, {
              x: xPos - 0.5,
              y: lineY - 0.8,
              w: 1.4,
              fontSize: 16,
              bold: true,
              color: data.themeColor,
              align: "center"
            });

            // Title
            pptSlide.addText(event.title, {
              x: xPos - 0.85,
              y: lineY + 0.3,
              w: 2.1,
              fontSize: 14,
              bold: true,
              align: "center",
              color: "333333"
            });
            
             // Description
            if (event.description) {
               pptSlide.addText(event.description, {
                x: xPos - 0.85,
                y: lineY + 0.8,
                w: 2.1,
                fontSize: 10,
                align: "center",
                color: "666666"
              });
            }
          });
        }
        break;

      case SlideType.PROCESS:
        pptSlide.addText(slide.title, { x: 0.5, y: 0.5, w: "90%", h: 0.8, fontSize: 32, bold: true, color: data.themeColor });
        
        if (slide.processSteps && slide.processSteps.length > 0) {
          const count = slide.processSteps.length;
          const startX = 0.5;
          const totalWidth = 9;
          const gap = 0.2;
          const boxWidth = (totalWidth - (gap * (count - 1))) / count;
          
          slide.processSteps.forEach((step, i) => {
             const x = startX + (i * (boxWidth + gap));
             
             // Shape: Chevron/Pentagon for Process Flow
             const shapeType = pres.ShapeType.pentagon; 
             
             pptSlide.addShape(shapeType, {
               x: x, 
               y: 2, 
               w: boxWidth, 
               h: 3,
               fill: { color: data.themeColor, transparency: 20 + (i * 10) },
               line: { color: "FFFFFF", width: 2 }
             });

             // Step Number
             pptSlide.addText(String(i + 1), {
               x: x,
               y: 2.2,
               w: boxWidth,
               h: 0.5,
               fontSize: 24,
               bold: true,
               color: "FFFFFF",
               align: "center"
             });

             // Step Title
             pptSlide.addText(step.title, {
               x: x + 0.1,
               y: 2.9,
               w: boxWidth - 0.2,
               h: 0.6,
               fontSize: 14,
               bold: true,
               color: "FFFFFF",
               align: "center",
               valign: "top"
             });

             // Step Description
             pptSlide.addText(step.description, {
               x: x + 0.1,
               y: 3.6,
               w: boxWidth - 0.2,
               h: 1.2,
               fontSize: 10,
               color: "FFFFFF",
               align: "center",
               valign: "top"
             });
          });
        }
        break;
    }
  });

  pres.writeFile({ fileName: `${data.topic}.pptx` });
};
